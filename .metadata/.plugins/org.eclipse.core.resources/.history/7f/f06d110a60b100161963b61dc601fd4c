package classes;

import java.util.ArrayList;
import java.util.List;
import java.util.Queue;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;

import server.ChannelManager;

public class Channel extends Thread {

private Lock lock = new ReentrantLock();
private Condition queueNotEmpty = lock.newCondition();

public String channelId;
public String clientId;
public String channelName;
public ArrayList<Song> songQueue;
public boolean isLive;

public String currentSongURI;
public long startTime;     // SYSTEM milliseconds
public long currentTime;     // ms, percent of duration
public long duration;     // ms, duration given by spotify

public Channel(String clientId, String channelId, String channelName){
	this.clientId = clientId;
	this.channelId = channelId;
	this.channelName = channelName;
	this.songQueue = new ArrayList<Song>();
	startTime = 0;
	isLive = false;
}

@Override
public void run() {
	while (true) {
		if (currentSongURI != null && currentTime < duration) {
			currentTime = System.currentTimeMillis() - startTime;
		} else startNextSong();
	}
}

public void startNextSong() {
	lock.lock();
	try {
		// check if queue empty
		while (songQueue.isEmpty()) {
			currentSongURI = null;
			duration = 0;
			currentTime = 0;
			startTime = 0;
			emitUpdate();
			System.out.println("Waiting for more songs in queue.");
			queueNotEmpty.await();
		}
		
		// after queue isn't empty...
		Song nextSong = songQueue.get(0);
		songQueue.remove(0);
		// replace current song
		currentSongURI = nextSong.getSongURI();
		duration = nextSong.getDuration();
		currentTime = 0;
		startTime = System.currentTimeMillis();
		System.out.println("START SONG " + currentSongURI);
		emitUpdate();
		
	} catch (InterruptedException e) {
		e.printStackTrace();
	}
	lock.unlock();
}

public void addSong(Song song) {
	lock.lock();
	songQueue.add(song);
	emitUpdate();
	lock.unlock();
}

public void replaceQueue(List<Song> newQueue) {
	lock.lock();
	this.songQueue = (ArrayList<Song>) newQueue;
	emitUpdate();
	lock.unlock();
}

public void setChannelName(String channelName) {
	this.channelName = channelName;
}

public void goLive() {
	isLive = true;
	if (!this.isAlive()) {
		this.start();
		emitUpdate();
	}
}

public void goOffline() {
	isLive = false;
	if (this.isAlive()) {
		this.interrupt();
		emitUpdate();
	}
}

public void emitUpdate() {
	JSONObject msg = new JSONObject();
	msg.put("emit", "channel_updated");
	msg.put("channel", this.channelId);
	msg.put("data", this.toJSON());
	ChannelManager.ws.sendAll(msg);
}

public JSONObject toJSON() {
	/* {
	    id: string,
	    hostId: string,
	    name: string,
	    favorite: bool,
	    isLive: bool,
	    currentTrackURI: string, (optional)
	    currentTrackTime: number, (optional)
	    currentTrackDuration: number (optional)
	   } */

	JSONObject obj = new JSONObject();

	obj.put("id", channelId);
	obj.put("hostId", clientId);
	obj.put("name", channelName);
	obj.put("favorite", false);
	obj.put("isLive", isLive);

	if (isLive) {
		obj.put("currentTrackURI", currentSongURI);
		obj.put("currentTrackStartTime", startTime);
		obj.put("currentTrackTime", currentTime);
		obj.put("currentTrackDuration", duration);
	}

	JSONArray songQueueJSON = new JSONArray();
	for (Song s : songQueue) {
		songQueueJSON.add(s.getSongURI());
	}

	obj.put("upNext", songQueueJSON);

	return obj;
}

}
